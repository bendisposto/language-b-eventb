'fileTypes': [
  'mch'
  'imp'
]
'name': 'Classical B'
'patterns': [
  {
    'begin': '/\\*'
    'captures':
      '0':
        'name': 'punctuation.definition.comment.classicalb'
    'end': '\\*/'
    'name': 'comment.block.classicalb'
  }
  {
    'begin': '"'
    'beginCaptures':
      '0':
        'name': 'punctuation.definition.string.begin.classicalb'
    'end': '"'
    'endCaptures':
      '0':
        'name': 'punctuation.definition.string.end.classicalb'
    'name': 'string.quoted.double.classicalb'
    'patterns': [
      {
        'match': '\\\\.'
        'name': 'constant.character.escape.classicalb'
      }
      {
        'match': '""'
        'name': 'constant.character.escape.quote.classicalb'
      }
    ]
  }
  {
    'match': 'MACHINE|INITIALIZATION|INITIALISATION|OPERATIONS|ASSERTIONS|SEES|PROMOTES|USES|INCLUDES|IMPORTS|REFINES|EXTENDS|REFINEMENT|CSP_CONTROLLER|SYSTEM|MODEL|IMPLEMENTATION|INVARIANT|CONCRETE_VARIABLES|ABSTRACT_VARIABLES|VARIABLES|PROPERTIES|CONSTANTS|ABSTRACT_CONSTANTS|CONCRETE_CONSTANTS|CONSTRAINTS|SETS|DEFINITIONS|VALUES'
    'name': 'keyword.machineclause.classicalb'
  }
  {
    'match': 'INTER|UNION|SIGMA|PI'
    'name': 'keyword.operator.set.classicalb'
  }
  {
    'match': ':'
    'name': 'operator.set.classicalb'
  }
  {
    'match': '-->|-->(>)?|>->(>)?|<->|>\+>(>)?'
    'name': 'operator.relation.classicalb'
  }
  {
    'match': '<--|:=|=(=)?(>)?|::'
    'name': 'operator.assignment.classicalb'
  }
# breaks test for some reason
#  {
#    'match': '\|\|'
#    'name': 'operator.parallel.classicalb'
#  }
  {
    'match': "\\b0'.\\b"
    'name': 'constant.numeric.classicalb'
  }
  {
    'match': 'MININT|MAXINT'
    'name': 'keyword.support.constant.numeric.classicalb'
  }
  {
    'match': 'TRUE|FALSE'
    'name': 'keyword.support.constant.boolean.classicalb'
  }
  # todo: add IN
  {
    'match': 'skip|LET|BE|VAR|ANY|WHILE|DO|VARIANT|ELSIF|IF|THEN|ELSE|EITHER|CASE|SELECT|ASSERT|WHEN|PRE|BEGIN|END|CHOICE|WHERE|OR|OF'
    'name': 'keyword.support.control.classicalb'
  }
  {
    'match': 'not|or'
    'name': 'keyword.operator.logical.classicalb'
  }
  {
    'match': '&'
    'name': 'operator.logical.classicalb'
  }
  {
    'match': 'first|last|tail|front'
    'name': 'keyword.operator.sequence.classicalb'
  }
  {
    'match': 'mod'
    'name': 'keyword.operator.numeric.classicalb'
  }
# should only match if followed by opening bracket
#  {
#    'match': 'min|max|card|union|inter|size'
#    'name': 'keyword.operator.set.classicalb'
#  }
  {
    'match': 'ran|dom'
    'name': 'keyword.operator.relation.classicalb'
  }
  {
    'match': 'bool'
    'name': 'keyword.operator.boolean.classicalb'
  }
  {
    'match': '\\b[a-zA-Z][a-zA-Z0-9_]*(?![(])\\b'
    'name': 'identifier.classicalb'
  }
  {
    'match': 'SET_PREF_\w*|FORCE_SYMMETRY_\w*|GOAL|ANIMATION_FUNCTION_DEFAULT|HEURISTIC_FUNCTION|ANIMATION_FUNCTION[0-9]*|ANIMATION_IMG\w*|ANIMATION_STR\w*|ASSERT_(LTL|CTL)\w*'
    'name': 'keyword.definition.classicalb'
  }

# todo: still missing:
#    syntax_type {((FIN(1?)|perm|i?seq1?|BOOL|struct|STRING|INT(EGER)?|NAT(URAL)?1?)(?=\M))}
#    syntax_operator {pred succ|id fnc rel rev conc rec closure1 closure iterate prj1 prj2 <=>}
#    syntax_operator {(\\|\|->|>=|<=(>)?|%|\*\*|~|(//)?<(<)?:|/(:|=)|<\+|\^|<-(>)?|<(<)?\||\
#                         \|>(>)?|\{|\}|\[\]|\|\[\]|<>|/(\|)?\\|\\(\|)?/)}
]
'scopeName': 'source.classicalb'
